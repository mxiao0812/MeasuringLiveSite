<!--
Created and maintained by student research assistants at the
          HELLER-HURWICZ ECONOMICS INSTITUTE
        University of Minnesota - Twin Cities

Last Updated: 12/20/2025
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <title> Data Center </title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Font-Family -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap">
  <!-- CSS Stylesheets -->
  <link rel="stylesheet" href="main.css">
  <link rel="stylesheet" href="datacenter.css">
  <!-- Icon -->
  <link rel="icon" type="image/png" href="images/HHEI.png">
  <!-- Charts -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>

<!-------------------------------------------------------------------------------------------------------------------->

<body>

<!-- RIBBON -->
<header>

  <!-- Selection Toggle, Title, Author -->
  <div id="header-left">

    <!-- Data Collection Selection Toggle -->
    <button id="toggle-select"
      class="pressable"
      title="Toggle Dataset Selection Menu"
      aria-label="Toggle Dataset Selection Menu" 
      onclick="toggleSelection()">
      â˜°
    </button>

    <!-- GitHub Repository -->
    <a href="https://github.com/mxiao0812/MeasuringLiveSite" target="_blank" title="Site Repository" class="pressable">
      <img id="github-link"
        alt="Site Repository" 
        src="https://github.githubassets.com/assets/GitHub-Mark-ea2971cee799.png">
    </a>

    <!-- Site Name & Author -->
    <h1>
      <a href="https://www.aeaweb.org/articles?id=10.1257/mac.2.4.88" target="_blank">
        Measuring Business Productivity and Value
      </a><br>
      <a id="author" href="http://users.econ.umn.edu/~erm/" target="_blank">
        Ellen McGrattan
      </a>
    </h1>

  </div>
  
  <!-- Tab Navigation -->
  <div id="tab-nav" role="tablist">   
    <button
      class="tab-btn pressable"
      onclick="location.href='index.html';"
      role="tab"
      aria-selected="false">
      Lectures
    </button>
    <button class="tab-btn active" role="tab" aria-selected="true"> Data Center </button> 
  </div>

  <!-- HHEI Web Link -->
  <div id="hhei-link">
    <a href="https://cla.umn.edu/heller-hurwicz" target="_blank"  class="pressable">
      <img 
      src="https://cla.umn.edu/sites/cla.umn.edu/files/HHEI%20wordmark.png"
      alt="Heller-Hurwicz Economics Institute" 
      id="hhei-logo">
    </a>
  </div>

</header>

<!------------------------------------------------------------------------------------------------------------>

<!-- DATA COLLECTION SELECTION -->
<div id="selection" class="hidden">

  <h2> Datasets </h2>

  <!-- IRS Statistics of Income  -->
  <a href="https://www.irs.gov/statistics/soi-tax-stats-statistics-of-income" target="_blank">
    <h3> IRS Statistics of Income (SOI) </h3>
  </a>

  <!-- All Corporations -->
  <button id="allcorp" class="selection-entry active" onclick=
    "buildTables(
      'allcorp',
      'Total assets', 
      'Less:  Cost of treasury stock',
      headers = ['Total assets', 'Total liabilities'],
      'ð˜šð˜µð˜¢ð˜µð˜ªð˜´ð˜µð˜ªð˜¤ð˜´ ð˜°ð˜§ ð˜ð˜¯ð˜¤ð˜°ð˜®ð˜¦. Internal Revenue Sevice. Washington, D.C.'
    ); highlightDataset(this);"
  ><p> All Corporations </p></button>

  <!-- S Corporations -->
  <button id="scorp" class="selection-entry" onclick=
    "buildTables(
      'scorp',
      'Total assets', 
      'Less:  Cost of treasury stock (1966-2019)',
      headers = ['Total assets', 'Total liabilities'],
      'ð˜šð˜µð˜¢ð˜µð˜ªð˜´ð˜µð˜ªð˜¤ð˜´ ð˜°ð˜§ ð˜ð˜¯ð˜¤ð˜°ð˜®ð˜¦. Internal Revenue Sevice. Washington, D.C.'
    ); highlightDataset(this);"
  ><p> S Corporations </p></button>

  <!-- Partnerships -->
  <button id="partners" class="selection-entry" onclick=
    "buildTables(
      'partners',
      'Total assets', 
      'Partners\' capital accounts',
      headers = ['Total assets', 'Total liabilities and capital'],
      'ð˜šð˜µð˜¢ð˜µð˜ªð˜´ð˜µð˜ªð˜¤ð˜´ ð˜°ð˜§ ð˜ð˜¯ð˜¤ð˜°ð˜®ð˜¦. Internal Revenue Sevice. Washington, D.C.'
    ); highlightDataset(this);"
  > <p> Partnerships </p> </button>


  <!-- BEA National Income and Product Accounts (NIPA) -->
  <a
    href="https://apps.bea.gov/iTable/?isuri=1&reqid=19&step=4&categories=flatfiles&nipa_table_list=1"
    target="_blank">
    <h3> BEA National Income and Product Accounts (NIPA) </h3>
  </a>

  <button id="DomesticProductAndIncome" class="selection-entry" onclick=
    "buildTables(
      'GDPGDI',
      'Gross domestic product', 
      'Statistical discrepancy',
      headers = ['Gross domestic product', 'Gross domestic income'],
      'ð˜•ð˜¢ð˜µð˜ªð˜°ð˜¯ð˜¢ð˜­ ð˜ð˜¯ð˜¤ð˜°ð˜®ð˜¦ ð˜¢ð˜¯ð˜¥ ð˜—ð˜³ð˜°ð˜¥ð˜¶ð˜¤ð˜µ ð˜ˆð˜¤ð˜¤ð˜°ð˜¶ð˜¯ð˜µð˜´. U.S. Bureau of Economic Analysis.'
    ); highlightDataset(this);"
  ><p> Gross Domestic Product And Income </p></button>

  <!-- Add new datasets here -->

  <button id="AdjustedAccounts" class="selection-entry" onclick=
    "buildTables(
      'adjustedgdpgdi',
      'Adjusted GDP', 
      'Adjusted GDI',
      headers = ['Adjusted GDP', 'Adjusted GDI'],
      'ð˜•ð˜¢ð˜µð˜ªð˜°ð˜¯ð˜¢ð˜­ ð˜ð˜¯ð˜¤ð˜°ð˜®ð˜¦ ð˜¢ð˜¯ð˜¥ ð˜—ð˜³ð˜°ð˜¥ð˜¶ð˜¤ð˜µ ð˜ˆð˜¤ð˜¤ð˜°ð˜¶ð˜¯ð˜µð˜´. U.S. Bureau of Economic Analysis.'
    ); highlightDataset(this);"
  ><p> Adjusted Gross Domestic Product And Income </p></button>

</div>

<!------------------------------------------------------------------------------------------------------------>

<!-- MAIN CONTENTS -->

<main>

  <div id="table-left" class="table"></div>
    
  <!-- Chart -->
  <div id="chart-container" class="content-container">

    <!-- Chart Download -->
    <div id="download-button-container">
      <button id="download-asset-chart"> Download Assets Chart </button>
      <button id="download-liability-chart"> Download Liabilities Chart </button>
      <button id="download-series"> Download Selected Series </button>
      <button id="download-full"> Download Full Dataset </button>
    </div>

    <!-- Chart Canvas-->
    <div id="chart-content">
      <div id="data-chart-left">
        <canvas id="assets-chart"></canvas>
      </div>
      <div id="data-chart-right">
        <canvas id="liabilities-chart"></canvas>
      </div>
      
      <div id="table-view-left" style="display:none;"></div>
      <div id="table-view-right" style="display:none;"></div>
    </div>

    <!-- Chart Update & Toggle View (Chart/Table) Buttons -->
    <div id="view-button-container">
      <button id="normalize-button">Normalize</button>
      <button id="update-chart">Update Data</button>
      <button id="toggle-view">Table View</button>
    </div>

  </div>

  <div id="table-right" class="table"></div>

</main>

<!------------------------------------------------------------------------------------------------------------>

<!-- YEAR SELECT -->
<div id="slider-years"> 1959 - 2022 </div>
<div id="slider-thumb-left" class="slider-thumb"></div>
<div id="slider-track-background"></div>
<div id="slider-track"></div>
<div id="slider-thumb-right" class="slider-thumb"></div>

<!------------------------------------------------------------------------------------------------------------>

<script>

  /* HTML ELEMENTS */

  /* RIBBON */
  const selectionToggle = document.getElementById('toggle-select');

  /* DATA COLLECTION SELECTION */
  const selection = document.getElementById('selection');
  const selectionEntries = selection.querySelectorAll('.selection-entry');

  /* MAIN CONTENTS */
  const main = document.querySelector('main');

    /* Tables */
  const leftTable = document.getElementById('table-left');
  const rightTable = document.getElementById('table-right');

  /* Chart */
  const downloadAssetChart = document.getElementById("download-asset-chart");
  const downloadLiabilityChart = document.getElementById("download-liability-chart");
  const downloadSeries = document.getElementById("download-series");
  const downloadFull = document.getElementById("download-full");
  const assetsChart = document.getElementById("assets-chart");
  const liabilitiesChart = document.getElementById("liabilities-chart");
  const applyBtn = document.getElementById("update-chart");
  const toggleViewBtn = document.getElementById("toggle-view");
  const tableViewLeft = document.getElementById("table-view-left");
  const tableViewRight = document.getElementById("table-view-right");
  const normalizeButton = document.getElementById("normalize-button");

  let isTableView = false;
  let isNormalized = false;

  /* Chart */
  let assetsChartInstance, liabilitiesChartInstance;
  let currentAssetVariable = null;
  let currentLiabilityVariable = null;

  /* YEAR SELECT */
  const sliderYears = document.getElementById("slider-years");
  const track = document.getElementById("slider-track");
  const leftThumb = document.getElementById("slider-thumb-left");
  const rightThumb = document.getElementById("slider-thumb-right");

/*********************************************************************************************************************/

  /* RIBBON */

  /* Dataset Selection Toggle */

  let isHidden = true;

  /**
   * Opens/closes dataset selection menu.
  */
  function toggleSelection() {
    // Show selection, hide previous/next buttons, and blur tab contents when selection open
    selection.classList.toggle('hidden');
    main.classList.toggle('blurred');

    // Update toggle button
    isHidden = !isHidden;
    selectionToggle.textContent = isHidden ? "â˜°" : "X";
  }

/*------------------------------------------------------------------------------------------------------------*/

  /* DATA COLLECTION SELECTION */

  // Number datasets
  selectionEntries.forEach((item, index) => {
      item.querySelector('p').textContent = `${index + 1}. ${item.textContent}`
  });


  // Bold dataset on click
  function highlightDataset(dataset) {
    selectionEntries.forEach(item => item.classList.remove('active'));
    dataset.classList.add('active');
  }

/*------------------------------------------------------------------------------------------------------------*/

  /* MAIN CONTENTS */

  /* Tables */

  // Data arrays
  let rawData = [];
  let adjustedData = [];
  let csvHeaders = [];

  // Track ancestor variables in 2D array and excluded series in a new set
  const hierarchy = [];
  const excludedSeries = new Set();
  
  // Track current data source
  let curSource;

  /**
   *  Parses a single CSV line into an array.
   * 
   *  @param {String} line - the raw text of the CSV line.
   * 
   *  @returns {Array} result - an array of the values in the CSV line.
   */ 
  function parseline(line) {
    const result = [];
    let current = "";
    let inQuotes = false;

    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      const next = line[i + 1];

      if (char === '"' && inQuotes && next === '"') { // Escaped quote
        current += '"';
        i++;
      } else if (char === '"') {
        inQuotes = !inQuotes;
      } else if (char === ',' && !inQuotes) {
        if (result.length === 0) { // Keep first column as string (with spaces for indentation)
          result.push(current); 
        } else {                   // Parse all other columns to float
          const cleaned = current.trim().replace(/,/g, '');
          const parsed = parseFloat(cleaned);
          result.push(isNaN(parsed) ? current : parsed);
        }
        current = "";
      } else {
        current += char;
      }
    }

    // Clean final value
    const parsed = parseFloat(current.trim().replace(/,/g, ''));
    result.push(isNaN(parsed) ? current : parsed);

    return result;
  }

  /**
   *  Loads selected lines from csv and parses into plot-ready format.
   * 
   *  @param {String} fname - the name of the chosen CSV file.
   * 
   *  @returns
   *    {Array<String>} csvHeaders - all values in the first row of the CSV.
   *    {Array<Array<String>>} rawData - a 2D array of all other values in the CSV.
   */ 
  async function loadCSV(fname) {

    // Load and clean CSV data
    const text = await fetch(`DATA/${fname}.csv`).then(r => r.text());
    const csv = text;
    const rows = text.split(/\r?\n/).filter(r => r.trim() !== "");

    // Parse CSV to plot-ready format
    rawData = [];
    rows.forEach((row, idx) => {
      const vals = parseline(row); // keep spaces for indentation
      if (idx === 0) csvHeaders = vals;
      if (idx === 0) csvHeaders = vals;
      else {
        // Store indentation and trim variable name
        const rawValue = vals[0];
        const value = rawValue.trim();
        const indent = rawValue.match(/^\s*/)[0].length;
        vals[0] = value;
        rawData.push({
          cols: vals,
          indent
        });
      }
    });
    
    return { rawData, csvHeaders };
  }

  /**
   *  Builds two tables from CSV data that plot a selected variable when clicked. Dynamically creates
   *    hierarchical structure of table based on the level of indentation used in the CSV.
   * 
   *  @param {String} fname - the filename of the CSV file.
   *  @param {String} startRow - the text content of the first cell of the first CSV row you wish to use.
   *  @param {String} endRow - the text content of the final cell of the first CSV row you wish to use.
   *  @param {Array<String>} headers - a string array of the headers for each of the two tables.
   *  @param {String} source - the source of the currently selected dataset 
   *      - E.g., Statistics of Income. Internal Revenue Service.
   * 
   *  Note: the startRow nor endRow strings should EXCLUDE leading or trailing spaces
  */ 
  async function buildTables(fname, startRow, endRow, headers, source) {
    
    const { rawData, csvHeaders } = await loadCSV(fname); // Load data

    // Clear tables & data
    leftTable.innerHTML = '';
    rightTable.innerHTML = '';
    excludedSeries.clear();
    adjustedData = [];
    const stack = [];

    // Initialize state variables
    let startRowFound = false;
    let endRowFound = false;
    let sectionContainer = leftTable;
    let leftHeaderAssigned = false;

    rawData.forEach((row, idx) => {

      // Get variable name and indent
      const value = row.cols[0];
      const indent = row.indent;

      if (value === startRow) startRowFound = true;
      if (!startRowFound || endRowFound) return; // Skip row if before start or after end
      if (value.includes("Addendum")) return;    // Skip designated rows

      // Variable names
      if (headers.includes(value)) {

        // Switch to right table for second header
        sectionContainer = leftHeaderAssigned ? rightTable : leftTable;
        leftHeaderAssigned = true;

        // Construct table header
        const h1 = document.createElement("h1");
        h1.textContent = value;
        sectionContainer.appendChild(h1);
        const headerTable = sectionContainer; 

        h1.addEventListener("click", () => {
          if (headerTable === leftTable) {
            currentAssetVariable = value;
          } else {
            currentLiabilityVariable = value;
          }
          updateChart();
        });

        stack.length = 0; // Reset stack

      } else { // Non-header value

        // Pop variables from the stack with a lower indent than current variable thus not an ancestor)
        while (stack.length && indent <= stack[stack.length - 1].indent) {
          stack.pop();
        }

        // Add to parent variable's list (if it exists)
        let parentUl = stack.length
          ? stack[stack.length - 1].var
          : null;

        // Create new unordered list & add to stack if no parent
        if (!parentUl) {
          parentUl = document.createElement("ul");
          sectionContainer.appendChild(parentUl);
          stack.push({ var: parentUl, indent });
        }

        // Get next row indent to determine if current value has descendant variables
        const nextRow = rawData[idx + 1];
        const nextIndent = nextRow ? nextRow.indent : -1;
        const willHaveChildren = nextIndent > indent;

        // Create new list item and add to parent list
        const li = nestedList(value, willHaveChildren);
        parentUl.appendChild(li);

        // Create new unordered list & add to stack if current value has descendant variables
        if (willHaveChildren) {
          const newUl = document.createElement("ul");
          newUl.style.display = "none"; // hide initially
          li.appendChild(newUl);
          stack.push({var: newUl, indent: (indent + 1)});
        }
      }

      if (value === endRow) endRowFound = true; // Check if designated last row found
    });

    // Additional state updates

    // Reset slider
    const years = csvHeaders.slice(1).map(Number).filter(y => !isNaN(y));
    appliedStart = startYear = minYear = Math.min(...years);
    appliedEnd = endYear = maxYear = Math.max(...years);
    sliderYears.textContent = `${minYear} - ${maxYear}`;
    resetSlider();

    curSource = source; // Update chart source

    // Plot initial variables for both charts
    const firstRow = rawData.find(r => r.cols[0].trim() === startRow);
    if (firstRow) {
      currentAssetVariable = headers[0];  // Total assets
      currentLiabilityVariable = headers[1];  // Total liabilities
      
      updateChart();  // Update both charts
    }

    toggleSelection(); // Toggle dataset selection menu

    /**
     *  Builds two tables from CSV data that plot a selected variable when clicked. Dynamically creates
     *  hierarchical structure of table based on the level of indentation used in the CSV.
     * 
     *  @param {String} text - the text content of the list item.
     *  @param {Boolean} hasChildren - indicates whether the current list item has descendant (nested) items.
     * 
     *  @returns {HTMLElement} li - an HTML list item
    */ 
    function nestedList(text, hasChildren) {

      // Create list item
      const li = document.createElement("li");
      li.style.cursor = "pointer";

      // Add arrow for dropdown if li has descendants
      let arrow;
      if (hasChildren) {
        arrow = document.createElement("span");
        arrow.textContent = "â–¶ ";
        arrow.style.userSelect = "none";
        li.appendChild(arrow);

        // Open/close dropdown on click
        arrow.addEventListener("click", e => {
          e.stopPropagation();
          const childUl = li.querySelector("ul");
          if (!childUl) return;
          if (childUl.style.display === "none") {
            childUl.style.display = "block";
            arrow.textContent = "â–¼ ";
          } else {
            childUl.style.display = "none";
            arrow.textContent = "â–¶ ";
          }
        });
      }

      // Button to exclude nested variables on click
      const excludeBtn = document.createElement("span");
      excludeBtn.textContent = "X ";
      excludeBtn.style.color = "red"
      li.appendChild(excludeBtn);

      // Text for list element
      const label = document.createElement("span");
      label.textContent = text;
      li.appendChild(label);
      li.dataset.plotValue = text;

      // Strikethrough label and excluded nested variables on click
      excludeBtn.addEventListener("click", e => {
        e.stopPropagation();
        toggleExclude(text);
        label.style.textDecoration = label.style.textDecoration === "line-through" ? "none" : "line-through";
      });

      // Plot variable on click
      label.addEventListener("click", e => {
        e.stopPropagation();
        
        const clickedLi = e.currentTarget.closest('li');
        if (!clickedLi) return;
        
        const isAsset = leftTable.contains(clickedLi);
        
        if (isAsset) {
          currentAssetVariable = clickedLi.dataset.plotValue;
        } else {
          currentLiabilityVariable = clickedLi.dataset.plotValue;
        }
        updateChart();
      });

      return li;
    }

  }

  /**
   *  Function to exclude/include value of nested variables on click.
   * 
   *  @param {String} variable - the text of the nested variable to be excluded
   * 
   */ 
  function toggleExclude(variable) {

    // Toggle whether variable is included or excluded
    if (excludedSeries.has(variable)) {
      excludedSeries.delete(variable);
    } else {
      excludedSeries.add(variable);
    }

    // Reset adjusted data seriees
    adjustedData = [];
    const stack = [];

    // Reconstruct adjusted data series
    rawData.forEach(row => {
      const newRow = { cols: [...row.cols], indent: row.indent };

      // Pop ancestors that are no longer parents
      while (stack.length && stack[stack.length - 1].indent >= row.indent) {
        stack.pop();
      }

      const add = row.cols[0].startsWith("Less:");    // Whether to add variable (if normally subtracted)

      // Subtract value from all ancestors in stack
      if (excludedSeries.has(row.cols[0])) {
        stack.forEach(ancestor => {
          for (let i = 1; i < ancestor.cols.length; i++) {
            let val = parseFloat(row.cols[i]);
            val = isNaN(val) ? 0 : val;               // Set val to 0 if NaN
            ancestor.cols[i] += add ? val : -val;   
          }
        });
      }

      // Push current row to stack as potential ancestor
      stack.push(newRow);
      adjustedData.push(newRow);

    });

    if (currentAssetVariable || currentLiabilityVariable) {
      updateChart();
    }
  }


  /* Chart */

  let chart;

  /* Chart Download for Assets */
  downloadAssetChart.addEventListener("click", () => {
    if (!assetsChartInstance) return;

    const link = document.createElement("a");
    link.download = `${currentAssetVariable || "assets"}.png`;
    link.href = assetsChartInstance.toBase64Image();  // FIXED: use assetsChartInstance
    link.click();
  });

  /* Chart Download for Liabilities */
  downloadLiabilityChart.addEventListener("click", () => {
    if (!liabilitiesChartInstance) return;

    const link = document.createElement("a");
    link.download = `${currentLiabilityVariable || "liabilities"}.png`;
    link.href = liabilitiesChartInstance.toBase64Image();  // FIXED: use liabilitiesChartInstance
    link.click();
  });

  // Download raw and adjusted values for selected series
  downloadSeries.addEventListener("click", () => {
    let output = "Year,Asset Raw,Asset Adjusted,Liability Raw,Liability Adjusted\n";
    
    const years = csvHeaders.slice(1).map(Number);
    
    const assetRow = rawData.find(r => r.cols[0] === currentAssetVariable);
    const liabilityRow = rawData.find(r => r.cols[0] === currentLiabilityVariable);
    
    if (!assetRow && !liabilityRow) return;
  
    const assetRawVals = assetRow ? assetRow.cols.slice(1).map(v => parseFloat(v)) : [];
    const assetAdjRow = adjustedData.find(r => r.cols[0] === currentAssetVariable);
    const assetAdjVals = assetAdjRow ? assetAdjRow.cols.slice(1).map(v => parseFloat(v)) : assetRawVals;
    
    const liabilityRawVals = liabilityRow ? liabilityRow.cols.slice(1).map(v => parseFloat(v)) : [];
    const liabilityAdjRow = adjustedData.find(r => r.cols[0] === currentLiabilityVariable);
    const liabilityAdjVals = liabilityAdjRow ? liabilityAdjRow.cols.slice(1).map(v => parseFloat(v)) : liabilityRawVals;
    
    for (let i = 0; i < years.length; i++) {
      if (years[i] >= startYear && years[i] <= endYear) {
        output += `${years[i]},${assetRawVals[i] || ''},${assetAdjVals[i] || ''},${liabilityRawVals[i] || ''},${liabilityAdjVals[i] || ''}\n`;
      }
    }
    
    const blob = new Blob([output], { type: "text/csv" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = `${currentAssetVariable}_${currentLiabilityVariable}_${startYear}-${endYear}.csv`;
    link.click();
  });

  // Download the full selected dataset
  downloadFull.addEventListener("click", () => {
    if (!csvHeaders.length || !rawData.length) return;

    let output = "";

    // Header row
    output += csvHeaders.join(",") + "\n";

    // Data rows (preserve indentation visually if you want)
    rawData.forEach(row => {
      const indent = " ".repeat(row.indent);
      const cols = [...row.cols];
      cols[0] = indent + cols[0];
      output += cols.join(",") + "\n";
    });

    const blob = new Blob([output], { type: "text/csv" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = "full_dataset.csv";
    link.click();
  });


  /* Chart Canvas */

  let currentVariable = null;

  function updateChart() {
    if (currentAssetVariable) {
      updateSingleChart('assets', currentAssetVariable, assetsChart, tableViewLeft);
    }
    if (currentLiabilityVariable) {
      updateSingleChart('liabilities', currentLiabilityVariable, liabilitiesChart, tableViewRight);
    }
  }

  /**
   *  Updates chart variable and year range.
   */ 
  function updateSingleChart(type, label, canvasElement, tableElement) {
    const row = rawData.find(r => r.cols[0] === label);
    if (!row) return;

    const allYears = csvHeaders.slice(1).map(Number);
    let allRaw = row.cols.slice(1).map(v => parseFloat(v));

    const rowAdjusted = adjustedData.find(r => r.cols[0] === label);
    let allAdj = rowAdjusted ? rowAdjusted.cols.slice(1).map(Number) : allRaw;

    // Apply normalization if enabled
    if (isNormalized) {
      const maxRaw = Math.max(...allRaw.filter(v => !isNaN(v)));
      const maxAdj = Math.max(...allAdj.filter(v => !isNaN(v)));
      const maxVal = Math.max(maxRaw, maxAdj, 1); // Avoid division by zero
      
      allRaw = allRaw.map(v => (v / maxVal) * 100);
      allAdj = allAdj.map(v => (v / maxVal) * 100);
    }

    const years = [];
    const rawVals = [];
    const adjVals = [];

    for (let i = 0; i < allYears.length; i++) {
      const y = allYears[i];
      if (y >= startYear && y <= endYear) {
        years.push(y);
        rawVals.push(allRaw[i]);
        adjVals.push(allAdj[i]);
      }
    }

    if (isTableView) {
      // TABLE VIEW
      canvasElement.parentElement.style.display = "none";
      tableElement.style.display = "block";
      
      if (type === 'assets' && assetsChartInstance) { 
        assetsChartInstance.destroy(); 
        assetsChartInstance = null; 
      }
      if (type === 'liabilities' && liabilitiesChartInstance) { 
        liabilitiesChartInstance.destroy(); 
        liabilitiesChartInstance = null; 
      }
      
      renderTable(label, years, rawVals, adjVals, tableElement);
      
    } else {
      // CHART VIEW
      tableElement.style.display = "none";
      canvasElement.parentElement.style.display = "block";
      
      if (type === 'assets' && assetsChartInstance) { 
        assetsChartInstance.destroy(); 
        assetsChartInstance = null; 
      }
      if (type === 'liabilities' && liabilitiesChartInstance) { 
        liabilitiesChartInstance.destroy(); 
        liabilitiesChartInstance = null; 
      }
      
      requestAnimationFrame(() => {
        renderChart(label, years, rawVals, adjVals, canvasElement, type);
      });
    }
  }

  function renderChart(label, years, rawValues, adjValues, canvasElement, type) {
    const ctx = canvasElement;
    
    // Construct chart
    const chart = new Chart(ctx, {
      type: "line",
      data: {
        labels: years,
        datasets: [
          { label: `Raw`, data: rawValues, borderColor: "blue", borderWidth: 2 },
          { label: `Adjusted`, data: adjValues, borderColor: "red", borderWidth: 2, borderDash: [5,5] }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: { mode: "index", intersect: false },
        plugins: {
          title: { 
            display: true, 
            text: `${type === 'assets' ? 'Assets: ' : 'Liabilities: '}${label}`, 
            font: { size: 16 } 
          },
          legend: { display: true }
        },
        scales: {
          x: { title: { display: true, text: 'Year' } },
          y: {
            title: {
              display: true,
              text: isNormalized ? 'Normalized Value (0-100)' : 'Raw Value (in dollars)'
            },
            ticks: {
              callback: function(v) {
                if (isNormalized) {
                  return Math.round(v);
                } else {
                  return v.toExponential(2);
                }
              }
            }
          }
        }
      }
    });
    
    // Store chart instance
    if (type === 'assets') {
      assetsChartInstance = chart;
    } else {
      liabilitiesChartInstance = chart;
    }

    // Force initial resize
    setTimeout(() => {
      chart.resize();
      chart.update('none');
    }, 100);
  }

  /* Update Chart */
  // Update years and hide button on click
  applyBtn.addEventListener("click", () => {
    appliedStart = startYear;
    appliedEnd   = endYear;

    updateChart();
    applyBtn.style.visibility = "hidden";
  });

  /* Toggle View */
  // Hide chart/table view on click to switch between views
  toggleViewBtn.addEventListener("click", () => {
    isTableView = !isTableView;
    toggleViewBtn.textContent = isTableView ? "Chart View" : "Table View";
    updateChart();
  });

  /* Normalize Data */
  normalizeButton.addEventListener("click", () => {
    isNormalized = !isNormalized;
    normalizeButton.textContent = isNormalized ? "Raw Data" : "Normalize";
    updateChart();
  });

/*------------------------------------------------------------------------------------------------------------*/

/* Table View */

function renderTable(label, years, rawValues, adjValues, tableElement) {
  let html = `<h3 style="margin: 0; text-align:center;">${label}</h3>`;
  if (isNormalized) {
    html += `<p style="text-align:center; margin:0.5rem 0; color:#666; font-size:0.9rem;">Values normalized to 0-100 scale</p>`;
  }
  html += `<table>
    <thead>
      <tr>
        <th>Year</th>
        <th>${isNormalized ? 'Normalized Raw' : 'Raw'}</th>
        <th>${isNormalized ? 'Normalized Adjusted' : 'Adjusted'}</th>
      </tr>
    </thead>
    <tbody>
  `;

  for (let i = 0; i < years.length; i++) {
    const y = years[i];
    const r = rawValues[i];
    const a = adjValues[i];

    html += `<tr>
      <td>${y}</td>
      <td>${Number.isFinite(r) ? (isNormalized ? r.toFixed(2) : r.toLocaleString()) : ""}</td>
      <td>${Number.isFinite(a) ? (isNormalized ? a.toFixed(2) : a.toLocaleString()) : ""}</td>
    </tr>`;
  }

  html += `</tbody></table>`;

  tableElement.innerHTML = html;
}

/*------------------------------------------------------------------------------------------------------------*/

  /* YEAR SELECT */
  let activeThumb = null;

  /**
   *  Makes active slider thumb resposive on click
   */ 
  function pointerDown(e) {
    activeThumb = e.target;

    document.body.style.cursor = "grabbing";
    activeThumb.classList.add("dragging");

    document.body.style.userSelect = "none";

    document.addEventListener("pointermove", pointerMove);
    document.addEventListener("pointerup", pointerUp);
  }

  /**
   *  Adjusts track and years on drag.
   */ 
  function pointerMove(e) {
    if (!activeThumb) return;

    const thumbWidth = activeThumb.getBoundingClientRect().width;

    // Constrain inside 4vwâ€“94vw
    const minX = window.innerWidth * 0.04 + thumbWidth / 2;
    const maxX = window.innerWidth * 0.94 + thumbWidth / 2;

    let x = Math.max(minX, Math.min(e.clientX, maxX));

    const leftRect = leftThumb.getBoundingClientRect();
    const rightRect = rightThumb.getBoundingClientRect();

    const rightLimit = rightRect.left + thumbWidth / 2;
    const leftLimit = leftRect.right - thumbWidth / 2;


    if (activeThumb === leftThumb) {
      // Prevent left thumb from going past right thumb
      x = Math.min(x, rightLimit);
      track.style.left = `${x}px`;
      track.style.width = `${rightLimit - x}px`;
    }

    if (activeThumb === rightThumb) {
      // Prevent right thumb from going past left thumb
      x = Math.max(x, leftLimit);
      track.style.width = `${x - leftLimit}px`;
    }

    activeThumb.style.left = `${x - thumbWidth / 2}px`;
    activeThumb.style.zIndex = "10";


    // Update years live based on thumb positions
    const totalYears = maxYear - minYear;

    const trackMin = window.innerWidth * 0.04;
    const trackMax = window.innerWidth * 0.94;
    const trackWidth = trackMax - trackMin;

    const leftPx = leftThumb.getBoundingClientRect().left;
    const rightPx = rightThumb.getBoundingClientRect().left;

    const leftPercent = (leftPx - trackMin) / trackWidth;
    const rightPercent = (rightPx - trackMin) / trackWidth;

    const leftYear = Math.round(minYear + leftPercent * totalYears);
    const rightYear = Math.round(minYear + rightPercent * totalYears);

    sliderYears.textContent = `${leftYear} - ${rightYear}`;

    startYear = leftYear;
    endYear   = rightYear;

    // If changed, show update button
    if (startYear !== appliedStart || endYear !== appliedEnd) {
      applyBtn.style.visibility = "visible";
    }

  }

  /**
   *  Removes event listeners when click lifted.
   */ 
  function pointerUp() {
    if (!activeThumb) return;

    activeThumb = null;
    document.body.style.userSelect = "auto";
    document.removeEventListener("pointermove", pointerMove);
    document.removeEventListener("pointerup", pointerUp);

    document.body.style.cursor = "default";
    leftThumb.classList.remove("dragging");
    rightThumb.classList.remove("dragging");
  }

  [leftThumb, rightThumb].forEach(thumb => {
    thumb.addEventListener("pointerdown", pointerDown);
  });

  /**
   *  Resets the slider.
   */ 
  function resetSlider() {
    const trackMin = window.innerWidth * 0.04;
    const trackMax = window.innerWidth * 0.94;
    const thumbWidth = leftThumb.getBoundingClientRect().width;

    leftThumb.style.left = `${trackMin - thumbWidth / 2}px`;
    rightThumb.style.left = `${trackMax - thumbWidth / 2}px`;

    track.style.left = `${trackMin}px`;
    track.style.width = `${trackMax - trackMin}px`;
  }

  // Build first table 
  buildTables(
    "allcorp",
    "Total assets", 
    "Less:  Cost of treasury stock",
    headers = ["Total assets", "Total liabilities"],
    'ð˜šð˜µð˜¢ð˜µð˜ªð˜´ð˜µð˜ªð˜¤ð˜´ ð˜°ð˜§ ð˜ð˜¯ð˜¤ð˜°ð˜®ð˜¦. Internal Revenue Sevice. Washington, D.C.'
  );

  // Force charts to resize when window changes
  let resizeTimeout;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      if (assetsChartInstance) {
        assetsChartInstance.resize();
        assetsChartInstance.update('none'); 
      }
      if (liabilitiesChartInstance) {
        liabilitiesChartInstance.resize();
        liabilitiesChartInstance.update('none'); 
      }
    }, 150); 
  });

</script>
</body>
</html>